<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Mobile Roblox-Style Clicker</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<style>
html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    touch-action: none;
    background: #000;
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
}
#game-container {
    position: relative;
    width: 100%;
    height: 100%;
    overflow: hidden;
}
#game {
    display: block;
    width: 100%;
    height: 100%;
    touch-action: none;
}

/* HUD */
#hud {
    position: absolute;
    top: 0.5rem;
    left: 0.5rem;
    right: 0.5rem;
    height: 3rem;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0.25rem 0.5rem;
    background: rgba(0,0,0,0.4);
    border-radius: 0.5rem;
    color: #fff;
    font-size: 0.9rem;
    pointer-events: none;
}
.hud-section {
    display: flex;
    gap: 0.6rem;
}
.hud-item {
    background: rgba(0,0,0,0.35);
    padding: 0.1rem 0.45rem;
    border-radius: 0.4rem;
}
.hud-label {
    font-size: 0.7rem;
    opacity: 0.7;
}
.hud-value {
    font-weight: 600;
}

/* Tabs */
#tab-bar {
    position: absolute;
    top: 3.8rem;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    gap: 0.4rem;
    background: rgba(0,0,0,0.5);
    padding: 0.25rem 0.4rem;
    border-radius: 0.75rem;
}
.tab-btn {
    border: none;
    background: rgba(255,255,255,0.07);
    color: #fff;
    padding: 0.35rem 0.7rem;
    font-size: 0.75rem;
    border-radius: 0.6rem;
    min-width: 3.2rem;
    text-align: center;
    touch-action: manipulation;
}
.tab-btn.active {
    background: rgba(0,180,255,0.8);
}

/* Panels */
#panels {
    position: absolute;
    top: 5.3rem;
    left: 50%;
    transform: translateX(-50%);
    width: min(90%, 540px);
    max-height: 45%;
    pointer-events: none;
}
.panel {
    display: none;
    background: rgba(0,0,0,0.8);
    border-radius: 0.8rem;
    padding: 0.6rem 0.8rem;
    color: #fff;
    font-size: 0.8rem;
    pointer-events: auto;
}
.panel.active {
    display: block;
}
.panel h2 {
    margin: 0 0 0.4rem 0;
    font-size: 0.9rem;
}
.panel-section-title {
    margin-top: 0.4rem;
    font-weight: 600;
    font-size: 0.8rem;
}
.panel-list {
    margin-top: 0.2rem;
    max-height: 8rem;
    overflow: hidden;
}
.panel-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 0.2rem 0;
}
.panel-row span {
    font-size: 0.8rem;
}
.panel-btn {
    border: none;
    border-radius: 0.4rem;
    padding: 0.25rem 0.5rem;
    font-size: 0.75rem;
    background: rgba(0,180,255,0.8);
    color: #fff;
    touch-action: manipulation;
}
.panel-btn:disabled {
    opacity: 0.5;
}
.small-text {
    font-size: 0.7rem;
    opacity: 0.85;
}

/* Joystick */
#joystick-area {
    position: absolute;
    left: 0;
    bottom: 0;
    width: 40%;
    height: 40%;
    max-width: 260px;
    max-height: 260px;
    padding: 0.75rem;
    box-sizing: border-box;
    touch-action: none;
}
#joystick-base {
    position: absolute;
    left: 0.75rem;
    bottom: 0.75rem;
    width: 140px;
    height: 140px;
    max-width: 45vw;
    max-height: 45vw;
    border-radius: 50%;
    background: rgba(0,0,0,0.35);
    border: 2px solid rgba(255,255,255,0.15);
}
#joystick-stick {
    position: absolute;
    left: 50%;
    top: 50%;
    width: 68px;
    height: 68px;
    margin-left: -34px;
    margin-top: -34px;
    border-radius: 50%;
    background: rgba(255,255,255,0.2);
    border: 2px solid rgba(255,255,255,0.35);
}

/* Camera area */
#camera-area {
    position: absolute;
    right: 0;
    bottom: 0;
    width: 55%;
    height: 55%;
    touch-action: none;
}

/* Action buttons */
#action-buttons {
    position: absolute;
    right: 0.75rem;
    bottom: 0.75rem;
    display: flex;
    flex-direction: column;
    gap: 0.4rem;
    align-items: flex-end;
    touch-action: manipulation;
}
.action-btn {
    min-width: 84px;
    min-height: 56px;
    padding: 0.3rem 0.6rem;
    font-size: 0.85rem;
    border-radius: 0.9rem;
    border: none;
    background: rgba(0,0,0,0.65);
    color: #fff;
    box-shadow: 0 0 0.3rem rgba(0,0,0,0.8);
}
#jump-btn {
    background: rgba(0,200,120,0.85);
}
#interact-btn {
    background: rgba(0,180,255,0.85);
}

/* Info toast */
#toast {
    position: absolute;
    bottom: 50%;
    left: 50%;
    transform: translate(-50%, 50%);
    background: rgba(0,0,0,0.8);
    color: #fff;
    padding: 0.35rem 0.7rem;
    border-radius: 0.6rem;
    font-size: 0.8rem;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.2s ease;
}
#toast.visible {
    opacity: 1;
}

/* Prevent text selection */
* {
    -webkit-user-select: none;
    -ms-user-select: none;
    user-select: none;
}
</style>
</head>
<body>
<div id="game-container">
    <canvas id="game"></canvas>

    <div id="hud">
        <div class="hud-section">
            <div class="hud-item">
                <div class="hud-label">Münzen</div>
                <div id="coins-display" class="hud-value">0</div>
            </div>
            <div class="hud-item">
                <div class="hud-label">Rebirths</div>
                <div id="rebirths-display" class="hud-value">0</div>
            </div>
        </div>
        <div class="hud-section">
            <div class="hud-item">
                <div class="hud-label">Welt</div>
                <div id="world-display" class="hud-value">Wiese</div>
            </div>
            <div class="hud-item">
                <div class="hud-label">Pet Multi</div>
                <div id="pet-multi-display" class="hud-value">1.00x</div>
            </div>
        </div>
    </div>

    <div id="tab-bar">
        <button class="tab-btn active" data-tab="upgrades-panel">Upgrades</button>
        <button class="tab-btn" data-tab="pets-panel">Pets</button>
        <button class="tab-btn" data-tab="worlds-panel">Welten</button>
        <button class="tab-btn" data-tab="shop-panel">Shop</button>
    </div>

    <div id="panels">
        <div id="upgrades-panel" class="panel active">
            <h2>Upgrades</h2>
            <div class="panel-list" id="upgrades-list"></div>
            <div class="small-text">Upgrades erhöhen Klick-, Auto-Farm-, Bewegungsgeschwindigkeit und Pet-Multis.</div>
        </div>
        <div id="pets-panel" class="panel">
            <h2>Pets</h2>
            <div class="panel-list" id="pets-list"></div>
            <div class="small-text">Pets erhöhen Klick- und Auto-Farm-Wert dauerhaft, solange sie im Besitz sind.</div>
        </div>
        <div id="worlds-panel" class="panel">
            <h2>Welten</h2>
            <div class="panel-list" id="worlds-list"></div>
            <div class="small-text">Laufe zu Portalen in der Welt oder nutze diese Liste, um zu wechseln (falls freigeschaltet).</div>
        </div>
        <div id="shop-panel" class="panel">
            <h2>Rebirth & Info</h2>
            <div id="rebirth-info" class="panel-list"></div>
            <div class="small-text">
                Rebirth setzt Münzen, Upgrades, Pets und Welt zurück, gibt aber Rebirth-Punkte für globale Multiplikatoren.
            </div>
        </div>
    </div>

    <div id="joystick-area">
        <div id="joystick-base">
            <div id="joystick-stick"></div>
        </div>
    </div>

    <div id="camera-area"></div>

    <div id="action-buttons">
        <button id="jump-btn" class="action-btn">Jump</button>
        <button id="interact-btn" class="action-btn">Interact</button>
    </div>

    <div id="toast"></div>
</div>

<script src="https://unpkg.com/three@0.165.0/build/three.min.js"></script>
<script>
(function() {
    "use strict";

    /* ---- Anti zoom / gestures ---- */
    var lastTouchEnd = 0;
    document.addEventListener("touchend", function(e) {
        var now = Date.now();
        if (now - lastTouchEnd <= 300) {
            e.preventDefault();
        }
        lastTouchEnd = now;
    }, { passive: false });

    document.addEventListener("touchmove", function(e) {
        if (e.touches && e.touches.length > 1) {
            e.preventDefault();
        }
    }, { passive: false });

    document.addEventListener("gesturestart", function(e) {
        e.preventDefault();
    }, { passive: false });

    document.addEventListener("wheel", function(e) {
        e.preventDefault();
    }, { passive: false });

    document.addEventListener("dblclick", function(e) {
        e.preventDefault();
    }, { passive: false });

    document.addEventListener("contextmenu", function(e) {
        e.preventDefault();
    });

    /* ---- DOM references ---- */
    var canvas = document.getElementById("game");
    var joystickArea = document.getElementById("joystick-area");
    var joystickBase = document.getElementById("joystick-base");
    var joystickStick = document.getElementById("joystick-stick");
    var cameraArea = document.getElementById("camera-area");
    var jumpBtn = document.getElementById("jump-btn");
    var interactBtn = document.getElementById("interact-btn");
    var toast = document.getElementById("toast");

    var coinsDisplay = document.getElementById("coins-display");
    var rebirthsDisplay = document.getElementById("rebirths-display");
    var worldDisplay = document.getElementById("world-display");
    var petMultiDisplay = document.getElementById("pet-multi-display");

    var upgradesList = document.getElementById("upgrades-list");
    var petsList = document.getElementById("pets-list");
    var worldsList = document.getElementById("worlds-list");
    var rebirthInfo = document.getElementById("rebirth-info");

    var tabButtons = Array.prototype.slice.call(document.querySelectorAll(".tab-btn"));
    var panels = Array.prototype.slice.call(document.querySelectorAll(".panel"));

    /* ---- Game state ---- */
    var saveKey = "roblox_style_clicker_save_v1";

    var gameState = {
        coins: 0,
        rebirths: 0,
        rebirthPoints: 0,
        upgrades: {
            click: 0,
            auto: 0,
            move: 0,
            pet: 0
        },
        pets: [],
        currentWorldIndex: 0,
        lastSave: 0
    };

    var upgradesConfig = {
        click: { name: "Klick-Upgrade", baseCost: 10, factor: 1.8, desc: "Erhöht Klick-Wert." },
        auto: { name: "Auto-Farm-Upgrade", baseCost: 25, factor: 1.9, desc: "Erhöht Auto-Farm pro Sekunde." },
        move: { name: "Movement-Speed-Upgrade", baseCost: 20, factor: 1.7, desc: "Erhöht Laufgeschwindigkeit." },
        pet: { name: "Pet-Multiplikator-Upgrade", baseCost: 50, factor: 2.0, desc: "Erhöht den Pet-Multiplikator." }
    };

    var worlds = [
        {
            name: "Wiese",
            groundColor: 0x55aa55,
            ambientColor: 0xffffff,
            skyColor: 0x87ceeb,
            multiplier: 1.0,
            require: null
        },
        {
            name: "Wüste",
            groundColor: 0xd2b48c,
            ambientColor: 0xffe0aa,
            skyColor: 0xfff1c1,
            multiplier: 1.5,
            require: { coins: 1000, rebirths: 0 }
        },
        {
            name: "Lava",
            groundColor: 0x552222,
            ambientColor: 0xffaaaa,
            skyColor: 0x330000,
            multiplier: 2.5,
            require: { coins: 0, rebirths: 2 }
        }
    ];

    var eggConfigs = [
        {
            worldIndex: 0,
            eggs: [
                {
                    id: "forest_basic",
                    name: "Wiesen-Ei",
                    cost: 50,
                    pets: [
                        { name: "Kaninchen", rarity: "Gewöhnlich", chance: 0.5, multiplier: 0.2 },
                        { name: "Fuchs", rarity: "Selten", chance: 0.3, multiplier: 0.6 },
                        { name: "Hirsch", rarity: "Episch", chance: 0.15, multiplier: 1.2 },
                        { name: "Einhorn", rarity: "Legendär", chance: 0.05, multiplier: 2.5 }
                    ]
                }
            ]
        },
        {
            worldIndex: 1,
            eggs: [
                {
                    id: "desert_basic",
                    name: "Wüsten-Ei",
                    cost: 150,
                    pets: [
                        { name: "Eidechse", rarity: "Gewöhnlich", chance: 0.55, multiplier: 0.3 },
                        { name: "Skorpion", rarity: "Selten", chance: 0.25, multiplier: 0.8 },
                        { name: "Falke", rarity: "Episch", chance: 0.15, multiplier: 1.8 },
                        { name: "Sand-Drache", rarity: "Legendär", chance: 0.05, multiplier: 3.2 }
                    ]
                }
            ]
        },
        {
            worldIndex: 2,
            eggs: [
                {
                    id: "lava_basic",
                    name: "Lava-Ei",
                    cost: 500,
                    pets: [
                        { name: "Feuer-Slime", rarity: "Gewöhnlich", chance: 0.5, multiplier: 0.6 },
                        { name: "Glut-Hund", rarity: "Selten", chance: 0.3, multiplier: 1.4 },
                        { name: "Magma-Golem", rarity: "Episch", chance: 0.15, multiplier: 3.0 },
                        { name: "Phönix", rarity: "Legendär", chance: 0.05, multiplier: 5.0 }
                    ]
                }
            ]
        }
    ];

    var rebirthBaseCost = 5000;
    var rebirthCostFactor = 3.2;

    /* ---- Three.js setup ---- */
    var renderer = new THREE.WebGLRenderer({
        canvas: canvas,
        antialias: true
    });
    renderer.setPixelRatio(window.devicePixelRatio || 1);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x87ceeb, 1);

    var scene = new THREE.Scene();

    var camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        500
    );
    camera.position.set(0, 5, 10);

    var ambientLight = new THREE.AmbientLight(0xffffff, 0.9);
    scene.add(ambientLight);

    var dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
    dirLight.position.set(5, 10, 7);
    scene.add(dirLight);

    var groundGeo = new THREE.PlaneGeometry(80, 80);
    var groundMat = new THREE.MeshPhongMaterial({ color: worlds[0].groundColor });
    var ground = new THREE.Mesh(groundGeo, groundMat);
    ground.rotation.x = -Math.PI / 2;
    ground.receiveShadow = true;
    scene.add(ground);

    var farmMat = new THREE.MeshPhongMaterial({ color: 0xdddd33 });
    var farmGeo = new THREE.BoxGeometry(2, 1, 2);
    var farmSpot = new THREE.Mesh(farmGeo, farmMat);
    farmSpot.position.set(0, 0.5, -4);
    scene.add(farmSpot);

    var playerGeo = new THREE.CapsuleGeometry(0.6, 1.2, 8, 16);
    var playerMat = new THREE.MeshPhongMaterial({ color: 0x0088ff });
    var player = new THREE.Mesh(playerGeo, playerMat);
    player.position.set(0, 1.1, 0);
    player.castShadow = true;
    scene.add(player);

    var portalMeshes = [];
    var eggMeshes = [];
    var worldPortalsData = [];

    function createWorldObjects() {
        var i;
        for (i = 0; i < portalMeshes.length; i++) {
            scene.remove(portalMeshes[i].mesh);
        }
        for (i = 0; i < eggMeshes.length; i++) {
            scene.remove(eggMeshes[i].mesh);
        }
        portalMeshes = [];
        eggMeshes = [];
        worldPortalsData = [];

        var worldRadius = 25;
        var portalGeo = new THREE.CylinderGeometry(0.8, 0.8, 3, 16);
        var colors = [0xffffff, 0xffdd88, 0xff6666];

        for (i = 0; i < worlds.length; i++) {
            var angle = (i / worlds.length) * Math.PI * 2;
            var x = Math.cos(angle) * worldRadius;
            var z = Math.sin(angle) * worldRadius;
            var mat = new THREE.MeshPhongMaterial({ color: colors[i % colors.length] });
            var mesh = new THREE.Mesh(portalGeo, mat);
            mesh.position.set(x, 1.5, z);
            scene.add(mesh);
            portalMeshes.push({
                mesh: mesh,
                worldIndex: i
            });
        }

        for (i = 0; i < eggConfigs.length; i++) {
            var conf = eggConfigs[i];
            var j;
            for (j = 0; j < conf.eggs.length; j++) {
                var eggConf = conf.eggs[j];
                var eggGeo = new THREE.SphereGeometry(0.6, 16, 16);
                var eggMat = new THREE.MeshPhongMaterial({ color: 0xffffff });
                var eggMesh = new THREE.Mesh(eggGeo, eggMat);
                var ex = -10 + conf.worldIndex * 8 + j * 2.5;
                var ez = 6 + conf.worldIndex * 0.5;
                eggMesh.position.set(ex, 0.6, ez);
                scene.add(eggMesh);
                eggMeshes.push({
                    mesh: eggMesh,
                    worldIndex: conf.worldIndex,
                    eggId: eggConf.id
                });
            }
        }

        worldPortalsData = portalMeshes;
    }

    createWorldObjects();

    /* ---- Camera & movement ---- */
    var cameraYaw = 0;
    var cameraPitch = 0.3;
    var cameraDistance = 8;
    var cameraHeight = 3;

    var moveVelX = 0;
    var moveVelZ = 0;
    var moveAccel = 18;
    var moveDeccel = 16;
    var baseMoveSpeed = 6;

    var jumpTime = 0;
    var jumpDuration = 0.45;
    var jumpPeak = 1.8;
    var isJumping = false;

    function getMoveSpeed() {
        var upgradeBonus = gameState.upgrades.move * 0.4;
        var rebirthBonus = gameState.rebirthPoints * 0.3;
        return baseMoveSpeed * (1 + upgradeBonus + rebirthBonus);
    }

    function updateCamera(dt) {
        var idealYaw = cameraYaw;
        var offsetX = Math.sin(idealYaw) * cameraDistance;
        var offsetZ = Math.cos(idealYaw) * cameraDistance;
        var targetPos = new THREE.Vector3(
            player.position.x - offsetX,
            player.position.y + cameraHeight,
            player.position.z - offsetZ
        );
        camera.position.lerp(targetPos, Math.min(1, dt * 8));
        camera.lookAt(player.position.x, player.position.y + 1.0, player.position.z);
    }

    function updateJump(dt) {
        if (isJumping) {
            jumpTime += dt;
            if (jumpTime >= jumpDuration) {
                isJumping = false;
                jumpTime = 0;
                player.position.y = 1.1;
            } else {
                var t = jumpTime / jumpDuration;
                var height = Math.sin(t * Math.PI) * jumpPeak;
                player.position.y = 1.1 + height;
            }
        }
    }

    /* ---- Joystick ---- */
    var joystickActive = false;
    var joystickTouchId = null;
    var joystickVector = { x: 0, y: 0 };

    function resetJoystick() {
        joystickVector.x = 0;
        joystickVector.y = 0;
        joystickStick.style.transform = "translate(-50%, -50%)";
    }

    joystickArea.addEventListener("touchstart", function(e) {
        var touches = e.changedTouches;
        if (!joystickActive && touches.length > 0) {
            var t = touches[0];
            joystickActive = true;
            joystickTouchId = t.identifier;
            updateJoystick(t);
            e.preventDefault();
        }
    }, { passive: false });

    joystickArea.addEventListener("touchmove", function(e) {
        if (!joystickActive) return;
        var touches = e.changedTouches;
        var i;
        for (i = 0; i < touches.length; i++) {
            var t = touches[i];
            if (t.identifier === joystickTouchId) {
                updateJoystick(t);
                e.preventDefault();
                break;
            }
        }
    }, { passive: false });

    joystickArea.addEventListener("touchend", function(e) {
        if (!joystickActive) return;
        var touches = e.changedTouches;
        var i;
        for (i = 0; i < touches.length; i++) {
            if (touches[i].identifier === joystickTouchId) {
                joystickActive = false;
                joystickTouchId = null;
                resetJoystick();
                e.preventDefault();
                break;
            }
        }
    }, { passive: false });

    joystickArea.addEventListener("touchcancel", function(e) {
        joystickActive = false;
        joystickTouchId = null;
        resetJoystick();
    }, { passive: false });

    function updateJoystick(touch) {
        var rect = joystickBase.getBoundingClientRect();
        var centerX = rect.left + rect.width / 2;
        var centerY = rect.top + rect.height / 2;
        var dx = touch.clientX - centerX;
        var dy = touch.clientY - centerY;
        var radius = rect.width / 2;
        var dist = Math.sqrt(dx * dx + dy * dy);
        var nx = dx;
        var ny = dy;
        if (dist > radius) {
            nx = (dx / dist) * radius;
            ny = (dy / dist) * radius;
        }
        joystickStick.style.transform = "translate(" + (nx) + "px, " + (ny) + "px)";
        joystickVector.x = nx / radius;
        joystickVector.y = ny / radius;
    }

    function getJoystickMagnitude() {
        return Math.sqrt(joystickVector.x * joystickVector.x + joystickVector.y * joystickVector.y);
    }

    function getMoveDirection() {
        var mag = getJoystickMagnitude();
        if (mag < 0.05) {
            return { x: 0, z: 0, mag: 0 };
        }
        var forward = {
            x: Math.sin(cameraYaw),
            z: Math.cos(cameraYaw)
        };
        var right = {
            x: Math.sin(cameraYaw + Math.PI / 2),
            z: Math.cos(cameraYaw + Math.PI / 2)
        };
        var forwardAmount = -joystickVector.y;
        var rightAmount = joystickVector.x;
        var dx = forward.x * forwardAmount + right.x * rightAmount;
        var dz = forward.z * forwardAmount + right.z * rightAmount;
        var len = Math.sqrt(dx * dx + dz * dz);
        if (len > 0) {
            dx /= len;
            dz /= len;
        }
        return { x: dx, z: dz, mag: mag };
    }

    /* ---- Camera touch control ---- */
    var cameraTouchId = null;
    var cameraLastX = 0;
    var cameraLastY = 0;
    var cameraSensitivity = 0.01;

    cameraArea.addEventListener("touchstart", function(e) {
        var touches = e.changedTouches;
        if (cameraTouchId === null && touches.length > 0) {
            var t = touches[0];
            cameraTouchId = t.identifier;
            cameraLastX = t.clientX;
            cameraLastY = t.clientY;
            e.preventDefault();
        }
    }, { passive: false });

    cameraArea.addEventListener("touchmove", function(e) {
        if (cameraTouchId === null) return;
        var touches = e.changedTouches;
        var i;
        for (i = 0; i < touches.length; i++) {
            var t = touches[i];
            if (t.identifier === cameraTouchId) {
                var dx = t.clientX - cameraLastX;
                var dy = t.clientY - cameraLastY;
                cameraLastX = t.clientX;
                cameraLastY = t.clientY;
                cameraYaw -= dx * cameraSensitivity;
                cameraPitch -= dy * cameraSensitivity * 0.5;
                var maxPitch = Math.PI / 3;
                var minPitch = -0.1;
                if (cameraPitch > maxPitch) cameraPitch = maxPitch;
                if (cameraPitch < minPitch) cameraPitch = minPitch;
                e.preventDefault();
                break;
            }
        }
    }, { passive: false });

    cameraArea.addEventListener("touchend", function(e) {
        if (cameraTouchId === null) return;
        var touches = e.changedTouches;
        var i;
        for (i = 0; i < touches.length; i++) {
            if (touches[i].identifier === cameraTouchId) {
                cameraTouchId = null;
                e.preventDefault();
                break;
            }
        }
    }, { passive: false });

    cameraArea.addEventListener("touchcancel", function() {
        cameraTouchId = null;
    }, { passive: false });

    /* ---- Click / tap farming ---- */
    function farmOnce() {
        var add = getClickValue();
        gameState.coins += add;
        showToast("+" + formatNumber(add.toFixed(0)) + " Münzen");
        updateHUD();
    }

    canvas.addEventListener("touchstart", function(e) {
        if (panelAnyActive()) return;
        e.preventDefault();
        farmOnce();
    }, { passive: false });

    canvas.addEventListener("mousedown", function(e) {
        if (panelAnyActive()) return;
        e.preventDefault();
        farmOnce();
    });

    /* ---- Actions ---- */
    jumpBtn.addEventListener("touchstart", function(e) {
        e.preventDefault();
        startJump();
    }, { passive: false });

    jumpBtn.addEventListener("click", function(e) {
        e.preventDefault();
        startJump();
    });

    interactBtn.addEventListener("touchstart", function(e) {
        e.preventDefault();
        handleInteract();
    }, { passive: false });

    interactBtn.addEventListener("click", function(e) {
        e.preventDefault();
        handleInteract();
    });

    function startJump() {
        if (!isJumping) {
            isJumping = true;
            jumpTime = 0;
        }
    }

    /* ---- Interactions ---- */
    function handleInteract() {
        var nearest = findNearestInteractive();
        if (!nearest) {
            farmOnce();
            return;
        }
        if (nearest.type === "farm") {
            farmOnce();
        } else if (nearest.type === "portal") {
            trySwitchWorld(nearest.worldIndex, true);
        } else if (nearest.type === "egg") {
            openEggById(nearest.eggId);
        } else {
            farmOnce();
        }
    }

    function findNearestInteractive() {
        var maxDist = 4;
        var bestDist = maxDist;
        var bestObj = null;
        var px = player.position.x;
        var pz = player.position.z;

        var dx = px - farmSpot.position.x;
        var dz = pz - farmSpot.position.z;
        var d = Math.sqrt(dx * dx + dz * dz);
        if (d < bestDist) {
            bestDist = d;
            bestObj = { type: "farm" };
        }

        var i;
        for (i = 0; i < worldPortalsData.length; i++) {
            var portal = worldPortalsData[i];
            dx = px - portal.mesh.position.x;
            dz = pz - portal.mesh.position.z;
            d = Math.sqrt(dx * dx + dz * dz);
            if (d < bestDist) {
                bestDist = d;
                bestObj = { type: "portal", worldIndex: portal.worldIndex };
            }
        }

        for (i = 0; i < eggMeshes.length; i++) {
            var egg = eggMeshes[i];
            dx = px - egg.mesh.position.x;
            dz = pz - egg.mesh.position.z;
            d = Math.sqrt(dx * dx + dz * dz);
            if (d < bestDist) {
                bestDist = d;
                bestObj = { type: "egg", eggId: egg.eggId };
            }
        }

        return bestObj;
    }

    function openEggById(eggId) {
        var conf = findEggConfig(eggId);
        if (!conf) {
            showToast("Kein Ei gefunden.");
            return;
        }
        if (gameState.coins < conf.cost) {
            showToast("Zu wenig Münzen für " + conf.name + ".");
            return;
        }
        gameState.coins -= conf.cost;
        var pet = rollPet(conf);
        gameState.pets.push(pet);
        showToast("Neues Pet: " + pet.name + " (" + pet.rarity + ", " + pet.multiplier.toFixed(2) + "x)");
        updateHUD();
        renderPetsList();
    }

    function findEggConfig(eggId) {
        var i, j;
        for (i = 0; i < eggConfigs.length; i++) {
            var worldEggs = eggConfigs[i].eggs;
            for (j = 0; j < worldEggs.length; j++) {
                if (worldEggs[j].id === eggId) {
                    return worldEggs[j];
                }
            }
        }
        return null;
    }

    function rollPet(eggConfig) {
        var rnd = Math.random();
        var cumulative = 0;
        var chosen = eggConfig.pets[eggConfig.pets.length - 1];
        var i;
        for (i = 0; i < eggConfig.pets.length; i++) {
            cumulative += eggConfig.pets[i].chance;
            if (rnd <= cumulative) {
                chosen = eggConfig.pets[i];
                break;
            }
        }
        return {
            name: chosen.name,
            rarity: chosen.rarity,
            multiplier: chosen.multiplier
        };
    }

    /* ---- Earnings ---- */
    function getTotalPetMultiplier() {
        var sum = 0;
        var i;
        for (i = 0; i < gameState.pets.length; i++) {
            sum += gameState.pets[i].multiplier;
        }
        var upgradeBonus = gameState.upgrades.pet * 0.1;
        return (1 + sum) * (1 + upgradeBonus);
    }

    function getRebirthMultiplier() {
        return 1 + gameState.rebirthPoints * 0.5;
    }

    function getWorldMultiplier() {
        var w = worlds[gameState.currentWorldIndex];
        return w ? w.multiplier : 1;
    }

    function getClickValue() {
        var base = 1 + gameState.upgrades.click;
        return base * getTotalPetMultiplier() * getRebirthMultiplier() * getWorldMultiplier();
    }

    function getAutoFarmPerSecond() {
        var base = gameState.upgrades.auto * 0.5;
        return base * getTotalPetMultiplier() * getRebirthMultiplier() * getWorldMultiplier();
    }

    /* ---- Rebirth ---- */
    function getRebirthCost() {
        return rebirthBaseCost * Math.pow(rebirthCostFactor, gameState.rebirths);
    }

    function canRebirth() {
        return gameState.coins >= getRebirthCost();
    }

    function doRebirth() {
        if (!canRebirth()) {
            showToast("Noch nicht genug Münzen für Rebirth.");
            return;
        }
        gameState.coins = 0;
        gameState.rebirths += 1;
        gameState.rebirthPoints += 1;
        gameState.upgrades.click = 0;
        gameState.upgrades.auto = 0;
        gameState.upgrades.move = 0;
        gameState.upgrades.pet = 0;
        gameState.pets = [];
        gameState.currentWorldIndex = 0;
        player.position.set(0, 1.1, 0);
        showToast("Rebirth! Globaler Multiplikator erhöht.");
        applyWorldVisuals();
        updateHUD();
        renderAllUI();
    }

    /* ---- UI Tabs ---- */
    tabButtons.forEach(function(btn) {
        btn.addEventListener("click", function(e) {
            e.preventDefault();
            var tabId = btn.getAttribute("data-tab");
            setActivePanel(tabId);
        });
        btn.addEventListener("touchstart", function(e) {
            e.preventDefault();
            var tabId = btn.getAttribute("data-tab");
            setActivePanel(tabId);
        }, { passive: false });
    });

    function setActivePanel(tabId) {
        tabButtons.forEach(function(b) {
            if (b.getAttribute("data-tab") === tabId) {
                b.classList.add("active");
            } else {
                b.classList.remove("active");
            }
        });
        panels.forEach(function(p) {
            if (p.id === tabId) {
                p.classList.add("active");
            } else {
                p.classList.remove("active");
            }
        });
    }

    function panelAnyActive() {
        var i;
        for (i = 0; i < panels.length; i++) {
            if (panels[i].classList.contains("active")) {
                return true;
            }
        }
        return false;
    }

    /* ---- UI rendering ---- */
    function renderUpgradesList() {
        upgradesList.innerHTML = "";
        var key;
        for (key in upgradesConfig) {
            if (Object.prototype.hasOwnProperty.call(upgradesConfig, key)) {
                var conf = upgradesConfig[key];
                var level = gameState.upgrades[key];
                var cost = computeUpgradeCost(key);
                var row = document.createElement("div");
                row.className = "panel-row";

                var left = document.createElement("span");
                left.textContent = conf.name + " (Lv. " + level + ")";
                var right = document.createElement("div");

                var costLabel = document.createElement("span");
                costLabel.textContent = formatNumber(cost.toFixed(0)) + " Münzen ";
                costLabel.style.marginRight = "0.35rem";

                var btn = document.createElement("button");
                btn.className = "panel-btn";
                btn.textContent = "Kaufen";
                if (gameState.coins < cost) {
                    btn.disabled = true;
                }
                (function(k) {
                    btn.addEventListener("click", function(e) {
                        e.preventDefault();
                        buyUpgrade(k);
                    });
                    btn.addEventListener("touchstart", function(e) {
                        e.preventDefault();
                        buyUpgrade(k);
                    }, { passive: false });
                })(key);

                right.appendChild(costLabel);
                right.appendChild(btn);

                row.appendChild(left);
                row.appendChild(right);
                upgradesList.appendChild(row);

                var desc = document.createElement("div");
                desc.className = "small-text";
                desc.textContent = conf.desc;
                upgradesList.appendChild(desc);
            }
        }
    }

    function renderPetsList() {
        petsList.innerHTML = "";
        if (gameState.pets.length === 0) {
            var empty = document.createElement("div");
            empty.className = "small-text";
            empty.textContent = "Noch keine Pets. Öffne Eier über Interact in der Welt!";
            petsList.appendChild(empty);
            return;
        }
        var i;
        for (i = 0; i < gameState.pets.length; i++) {
            var pet = gameState.pets[i];
            var row = document.createElement("div");
            row.className = "panel-row";
            var left = document.createElement("span");
            left.textContent = pet.name + " (" + pet.rarity + ")";
            var right = document.createElement("span");
            right.textContent = pet.multiplier.toFixed(2) + "x";
            row.appendChild(left);
            row.appendChild(right);
            petsList.appendChild(row);
        }
    }

    function renderWorldsList() {
        worldsList.innerHTML = "";
        var i;
        for (i = 0; i < worlds.length; i++) {
            (function(index) {
                var w = worlds[index];
                var can = isWorldUnlocked(index);
                var row = document.createElement("div");
                row.className = "panel-row";
                var left = document.createElement("span");
                var suffix = index === gameState.currentWorldIndex ? " (Aktiv)" : "";
                left.textContent = w.name + suffix;
                var right = document.createElement("div");
                var info = document.createElement("span");
                info.style.marginRight = "0.35rem";
                if (!w.require) {
                    info.textContent = "Standardwelt";
                } else {
                    var reqCoins = w.require.coins || 0;
                    var reqRebirths = w.require.rebirths || 0;
                    info.textContent = "Benötigt " + formatNumber(reqCoins) + " Münzen, " + reqRebirths + " Rebirths";
                }
                var btn = document.createElement("button");
                btn.className = "panel-btn";
                btn.textContent = "Teleport";
                if (!can || index === gameState.currentWorldIndex) {
                    btn.disabled = true;
                }
                btn.addEventListener("click", function(e) {
                    e.preventDefault();
                    trySwitchWorld(index, true);
                });
                btn.addEventListener("touchstart", function(e) {
                    e.preventDefault();
                    trySwitchWorld(index, true);
                }, { passive: false });
                right.appendChild(info);
                right.appendChild(btn);
                row.appendChild(left);
                row.appendChild(right);
                worldsList.appendChild(row);
            })(i);
        }
    }

    function renderRebirthInfo() {
        rebirthInfo.innerHTML = "";
        var row1 = document.createElement("div");
        row1.className = "panel-row";
        var left = document.createElement("span");
        left.textContent = "Aktuelle Rebirths: " + gameState.rebirths;
        var right = document.createElement("span");
        right.textContent = "Punkte: " + gameState.rebirthPoints;
        row1.appendChild(left);
        row1.appendChild(right);
        rebirthInfo.appendChild(row1);

        var row2 = document.createElement("div");
        row2.className = "panel-row";
        var left2 = document.createElement("span");
        left2.textContent = "Globaler Multiplikator";
        var right2 = document.createElement("span");
        right2.textContent = getRebirthMultiplier().toFixed(2) + "x";
        row2.appendChild(left2);
        row2.appendChild(right2);
        rebirthInfo.appendChild(row2);

        var costRow = document.createElement("div");
        costRow.className = "panel-row";
        var left3 = document.createElement("span");
        left3.textContent = "Kosten für nächsten Rebirth";
        var right3 = document.createElement("span");
        right3.textContent = formatNumber(getRebirthCost().toFixed(0)) + " Münzen";
        costRow.appendChild(left3);
        costRow.appendChild(right3);
        rebirthInfo.appendChild(costRow);

        var btnRow = document.createElement("div");
        btnRow.className = "panel-row";
        var spacer = document.createElement("span");
        spacer.textContent = "";
        var btnWrap = document.createElement("div");
        var btn = document.createElement("button");
        btn.className = "panel-btn";
        btn.textContent = "Rebirth jetzt";
        if (!canRebirth()) btn.disabled = true;
        btn.addEventListener("click", function(e) {
            e.preventDefault();
            doRebirth();
        });
        btn.addEventListener("touchstart", function(e) {
            e.preventDefault();
            doRebirth();
        }, { passive: false });
        btnWrap.appendChild(btn);
        btnRow.appendChild(spacer);
        btnRow.appendChild(btnWrap);
        rebirthInfo.appendChild(btnRow);
    }

    function renderAllUI() {
        renderUpgradesList();
        renderPetsList();
        renderWorldsList();
        renderRebirthInfo();
        updateHUD();
    }

    function updateHUD() {
        coinsDisplay.textContent = formatNumber(gameState.coins.toFixed(0));
        rebirthsDisplay.textContent = formatNumber(gameState.rebirths);
        var w = worlds[gameState.currentWorldIndex];
        worldDisplay.textContent = w ? w.name : "Unbekannt";
        petMultiDisplay.textContent = getTotalPetMultiplier().toFixed(2) + "x";
    }

    function computeUpgradeCost(key) {
        var level = gameState.upgrades[key] || 0;
        var conf = upgradesConfig[key];
        var cost = conf.baseCost * Math.pow(conf.factor, level);
        if (cost < conf.baseCost) cost = conf.baseCost;
        return cost;
    }

    function buyUpgrade(key) {
        var cost = computeUpgradeCost(key);
        if (gameState.coins < cost) {
            showToast("Zu wenig Münzen.");
            return;
        }
        gameState.coins -= cost;
        gameState.upgrades[key] = (gameState.upgrades[key] || 0) + 1;
        showToast(upgradesConfig[key].name + " Level " + gameState.upgrades[key]);
        renderAllUI();
    }

    function isWorldUnlocked(index) {
        var w = worlds[index];
        if (!w.require) return true;
        var coinsReq = w.require.coins || 0;
        var rebirthReq = w.require.rebirths || 0;
        if (gameState.coins >= coinsReq && gameState.rebirths >= rebirthReq) {
            return true;
        }
        if (gameState.rebirths > rebirthReq) {
            return true;
        }
        return false;
    }

    function trySwitchWorld(index, viaUI) {
        if (index === gameState.currentWorldIndex) return;
        if (!isWorldUnlocked(index)) {
            if (viaUI) {
                showToast("Welt noch gesperrt.");
            }
            return;
        }
        gameState.currentWorldIndex = index;
        player.position.set(0, 1.1, 0);
        applyWorldVisuals();
        renderAllUI();
        showToast("Reise nach: " + worlds[index].name);
    }

    function applyWorldVisuals() {
        var w = worlds[gameState.currentWorldIndex];
        if (!w) return;
        ground.material.color.setHex(w.groundColor);
        ambientLight.color.setHex(w.ambientColor);
        renderer.setClearColor(w.skyColor, 1);
    }

    /* ---- Toast ---- */
    var toastTimeout = null;
    function showToast(text) {
        toast.textContent = text;
        toast.classList.add("visible");
        if (toastTimeout) {
            clearTimeout(toastTimeout);
        }
        toastTimeout = setTimeout(function() {
            toast.classList.remove("visible");
        }, 1200);
    }

    /* ---- Save & Load ---- */
    function saveGame() {
        try {
            var data = JSON.stringify(gameState);
            localStorage.setItem(saveKey, data);
        } catch (err) {
            /* ignore */
        }
    }

    function loadGame() {
        try {
            var raw = localStorage.getItem(saveKey);
            if (!raw) return;
            var data = JSON.parse(raw);
            if (typeof data !== "object" || !data) return;
            if (typeof data.coins === "number") gameState.coins = data.coins;
            if (typeof data.rebirths === "number") gameState.rebirths = data.rebirths;
            if (typeof data.rebirthPoints === "number") gameState.rebirthPoints = data.rebirthPoints;
            if (data.upgrades) {
                if (typeof data.upgrades.click === "number") gameState.upgrades.click = data.upgrades.click;
                if (typeof data.upgrades.auto === "number") gameState.upgrades.auto = data.upgrades.auto;
                if (typeof data.upgrades.move === "number") gameState.upgrades.move = data.upgrades.move;
                if (typeof data.upgrades.pet === "number") gameState.upgrades.pet = data.upgrades.pet;
            }
            if (Array.isArray(data.pets)) {
                gameState.pets = data.pets.map(function(p) {
                    return {
                        name: p.name || "Pet",
                        rarity: p.rarity || "Unbekannt",
                        multiplier: typeof p.multiplier === "number" ? p.multiplier : 1
                    };
                });
            }
            if (typeof data.currentWorldIndex === "number") {
                if (data.currentWorldIndex >= 0 && data.currentWorldIndex < worlds.length) {
                    gameState.currentWorldIndex = data.currentWorldIndex;
                }
            }
        } catch (err) {
            /* ignore */
        }
    }

    setInterval(function() {
        saveGame();
    }, 10000);

    /* ---- Utility ---- */
    function formatNumber(num) {
        var n = typeof num === "string" ? parseFloat(num) : num;
        if (!isFinite(n)) return "0";
        if (n >= 1e9) return (n / 1e9).toFixed(2) + "B";
        if (n >= 1e6) return (n / 1e6).toFixed(2) + "M";
        if (n >= 1e3) return (n / 1e3).toFixed(1) + "k";
        return Math.round(n).toString();
    }

    /* ---- Game loop ---- */
    var lastTime = performance.now();
    var autoFarmAccumulator = 0;

    function update(dt) {
        var dir = getMoveDirection();
        var speed = getMoveSpeed() * dir.mag;
        var targetVx = dir.x * speed;
        var targetVz = dir.z * speed;

        moveVelX += (targetVx - moveVelX) * Math.min(1, moveAccel * dt);
        moveVelZ += (targetVz - moveVelZ) * Math.min(1, moveAccel * dt);
        if (dir.mag < 0.05) {
            moveVelX -= moveVelX * Math.min(1, moveDeccel * dt);
            moveVelZ -= moveVelZ * Math.min(1, moveDeccel * dt);
        }

        player.position.x += moveVelX * dt;
        player.position.z += moveVelZ * dt;
        var maxX = 36;
        var maxZ = 36;
        if (player.position.x > maxX) player.position.x = maxX;
        if (player.position.x < -maxX) player.position.x = -maxX;
        if (player.position.z > maxZ) player.position.z = maxZ;
        if (player.position.z < -maxZ) player.position.z = -maxZ;

        updateJump(dt);

        autoFarmAccumulator += dt;
        if (autoFarmAccumulator >= 1) {
            autoFarmAccumulator -= 1;
            var autoGain = getAutoFarmPerSecond();
            if (autoGain > 0) {
                gameState.coins += autoGain;
                updateHUD();
            }
        }

        updateCamera(dt);
    }

    function loop(time) {
        var dt = (time - lastTime) / 1000;
        if (dt > 0.1) dt = 0.1;
        lastTime = time;

        update(dt);
        renderer.render(scene, camera);
        requestAnimationFrame(loop);
    }

    window.addEventListener("resize", function() {
        var w = window.innerWidth;
        var h = window.innerHeight;
        renderer.setSize(w, h);
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
    });

    /* ---- Init ---- */
    loadGame();
    applyWorldVisuals();
    renderAllUI();
    requestAnimationFrame(loop);
})();
</script>
</body>
</html>
